<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>BST Notes by Fahim Ahmed</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
  <script src="script.js"></script>
  <style src= "style.css"> </style>
</head>

<body>
  <div class="container">
    <!-- Content here -->
    <h1 class="display-6 pt-3 pb-3" style="text-align: center;">Binary Search Tree (BST)</h1>
    

    <!-- END OF ALERT -->

    <div class="alert alert-warning alert-dismissible fade show" role="alert">
      <strong>New Module!</strong> Check BST to Grater Sum Tree! 
      <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>
    <!--grid-->

    <div class="container mb-10  mt-10">
      <div class="d-lg-flex">
        <div class="col order-last">
          <figure class="figure">
            <img src="bst.png" class="figure-img img-fluid rounded" alt="...">
            <figcaption class="figure-caption text-end">*Image Collected from internet</figcaption>
          </figure>
        </div>
        
        <div class="col order-first">
          <strong>Binary Search Tree (BST)</strong> is a node-based binary tree data structure which has the following properties:<br> 
          <ul>
            <li>The left subtree of a node contains only nodes with keys <mark>lesser</mark> than the node’s key.</li>
            <li>The right subtree of a node contains only nodes with keys <mark>grater</mark> than the node’s key.</li>
            <li>The left and right subtree each must also be a binary search tree.</li>
          </ul>
          
          
          
        </div>
      </div>
    </div>

    <!--grid end-->
    <div class="accordion" id="accordionPanelsStayOpenExample">
      <div class="accordion-item">
        <h2 class="accordion-header" id="panelsStayOpen-headingOne">
          <button class="accordion-button" type="button" data-bs-toggle="collapse"
            data-bs-target="#panelsStayOpen-collapseOne" aria-expanded="false"
            aria-controls="panelsStayOpen-collapseOne">
            Insertion in a BST – Recursive Solution
          </button>
        </h2>
        <div id="panelsStayOpen-collapseOne" class="accordion-collapse collapse in"
          aria-labelledby="panelsStayOpen-headingOne">
          <div class="accordion-body">
            <img src="insert_recursion.png" class="img-thumbnail">
            <hr>
            When looking for a place to insert a new key, traverse the tree from root-to-leaf, making comparisons to
            keys stored in the tree’s nodes and deciding based on the comparison to continue searching in the left or
            right subtrees. In other words, we examine the root and recursively insert the new node to the left subtree
            if its key is less than that of the root or the right subtree if its key is greater than or equal to the
            root. Here is an example of function <span class="badge bg-secondary">insert</span> in BST.
            <hr>
            <pre>
def insert(root, key):

  if root is None: return Node(key)

  if key < root.data:
  root.left = insert(root.left, key)
  else:
    root.right = insert(root.right, key)

  return root
              </pre>
            Check out this leetcode problem --> <span class="badge bg-warning"> <a href = "https://leetcode.com/problems/insert-into-a-binary-search-tree/" class="text-decoration-none" style="color: white">701. Insert into a Binary Search Tree</a></span>
          </div>
        </div>
      </div>
      <div class="accordion-item">
        <h2 class="accordion-header" id="panelsStayOpen-headingTwo">
          <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
            data-bs-target="#panelsStayOpen-collapseTwo" aria-expanded="false"
            aria-controls="panelsStayOpen-collapseTwo">
            Balanced BST from a sorted List / Array
          </button>
        </h2>
        <div id="panelsStayOpen-collapseTwo" class="accordion-collapse collapse"
          aria-labelledby="panelsStayOpen-headingTwo">
          <div class="accordion-body">

            Lets say, you are given a sorted list/array of numbers. You have to construct a balanced BST from it. 

            <!-- Button trigger modal -->
            <span type="button" class="badge text-bg-success" data-bs-toggle="modal" data-bs-target="#exampleModal">
              What is a Balanced Binary Tree? 
            </span>

            <!-- Modal -->
            <div class="modal fade" id="exampleModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
              <div class="modal-dialog">
                <div class="modal-content">
                  <div class="modal-header">
                    <h1 class="modal-title fs-5" id="exampleModalLabel">Balanced Binary Tree</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                  </div>
                  <div class="modal-body">
                    A <strong> balanced binary tree </strong>, also referred to as a height-balanced binary tree, is defined as a binary tree in which the height of the left and right subtree of any node differ by not more than 1.
             <hr>
   <pre>
keys = [15, 10, 20, 8, 12, 16, 25]
     
        15
      /    \
    10      20
   /  \    /  \
  8   12  16  25  </pre>
                  </div>
                  <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                  
                  </div>
                </div>
              </div>
            </div>
            <!-- END OF MODAL -->
<br><br> 
           <strong>Problem: </strong>Adding data to a regular Binary Search Tree (BST) can be slow in the worst case. If you add data in order (ascending or descending), the tree becomes unbalanced and searching for things takes longer.
<br>
            <strong>Solution:</strong> We want a <span class="badge text-bg-dark">Hight Balanced</span> BST, where the tree's depth grows slowly (like a log) even with lots of data. This makes searching much faster.
<br><br>
            <strong>How to achieve it: </strong> <br><br>


            <ol>
              <li>
                <strong>Sort the data first:</strong>
                <p>This ensures the tree structure is balanced from the start, meaning it won't be lopsided and searching will be faster.</p>
              </li>
              <li>
                <strong>Pick the middle element:</strong>
                <p>This element becomes the <code>root</code> of the tree. It's like the main trunk from which all other branches grow.</p>
              </li>
              <li>
                <strong>Add smaller elements to the left:</strong>
                <p>These elements are less than the root, so they go in the <code>left subtree</code>. Think of it as the left side of the family tree.</p>
              </li>
              <li>
                <strong>Add larger elements to the right:</strong>
                <p>These elements are more than the root, so they go in the <code>right subtree</code>. It's like the right side of the family tree.</p>
              </li>
              <li>
                <strong>Repeat steps 2-4 for each subtree:</strong>
                <p>Keep dividing the remaining data and building subtrees based on their values compared to the parent node. Imagine splitting the family tree branches further for each new generation.</p>
              </li>
            </ol>



            We can easily modify the solution to get height-balanced BSTs if all keys are known in advance. The idea is to sort the given keys first. Then the root will be the middle element of the sorted array, and we <strong>recursively</strong> construct the left subtree of the root by keys less than the middle element and the right subtree of the root by keys more than the middle element.<hr> For example, lets say we have the array <code> keys = [15, 10, 20, 8, 12, 16, 25]</code>. After <span class="badge bg-secondary">sorting</span> the array, we get <code>[8, 10, 12, 15, 16, 20, 25]</code>. <br> Now we take the mid element <code>15</code> and split the array into two subarrays <code>[8, 10, 12]</code> and <code>[16, 20, 25]</code>. <br>

            Now we again take the mid element of the left subtree and make that the left node of the current root.
            <pre> 
      15
     /  \
    10   (same as the left sub-tree)
   /  \
  8   12        </pre>

            By repeating this process, we can construct the balanced BST. <br> 
            Time Complexity <mark>O(nlog(n))</mark> 
             <hr> <pre>
def Balanced_BST(keys, low, high, root):
  if low > high: return root

  mid = (low + high) // 2
  root = Node(keys[mid])

  root.left = Balanced_BST(keys, low, mid-1, root.left)
  root.right = Balanced_BST(keys, mid+1, high, root.right)
            
  return root</pre>
              Check out this leetcode problem --> <span class="badge bg-success"> <a href = "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" class="text-decoration-none" style="color: white">108. Convert Sorted Array to Binary Search Tree</a></span>
          </div>
        </div>
      </div>
      <div class="accordion-item">
        <h2 class="accordion-header" id="panelsStayOpen-headingThree">
          <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
            data-bs-target="#panelsStayOpen-collapseThree" aria-expanded="false"
            aria-controls="panelsStayOpen-collapseThree">
            Traversals - Pre, In, Post Order
          </button>
        </h2>
        <div id="panelsStayOpen-collapseThree" class="accordion-collapse collapse"
          aria-labelledby="panelsStayOpen-headingThree">
          <div class="accordion-body">

            <strong>Inorder Traversal</strong>

            <ul>
            <li>Visits nodes in the order: left subtree, root, right subtree.</li>
            <li>In a BST, inorder traversal lists nodes in ascending order.</li>
            </ul>

            <p>Uses:</p>

            <ul>
            <li>Printing elements in ascending order.</li>
            <li>Validating a BST.</li>
            </ul>

            <strong>Preorder Traversal</strong>

            <ul>
            <li>Visits nodes in the order: root, left subtree, right subtree.</li>
            <li>Useful for copying a BST or creating a preorder index.</li>
            </ul>

            <p>Uses:</p>

            <ul>
            <li>Creating a copy of a BST.</li>
            <li>Building a preorder index.</li>
            </ul>

            <strong>Postorder Traversal</strong>

            <ul>
            <li>Visits nodes in the order: left subtree, right subtree, root.</li>
            <li>Often used for deleting a BST or calculating its height.</li>
            </ul>

            <p>Uses:</p>

            <ul>
            <li>Deleting a BST.</li>
            <li>Calculating the height of a BST.</li>
            </ul>


            
          </div>
        </div>
      </div>
      <!--forth starts--> 
      <div class="accordion-item">
        <h2 class="accordion-header" id="panelsStayOpen-headingFour">
          <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelsStayOpen-collapseFour" aria-expanded="false" aria-controls="panelsStayOpen-collapseThree">
            Mirror A Binary Search Tree
          </button>
        </h2>
        <div id="panelsStayOpen-collapseFour" class="accordion-collapse collapse" aria-labelledby="panelsStayOpen-headingFour">
          <div class="accordion-body">
            Given a Binary Tree, the task is to convert the binary tree into its Mirror tree. Mirror of a Binary Tree T is another Binary Tree M(T) with left and right children of all non-leaf nodes interchanged. <br><br>
            <pre class= "border">
              
       15                        15
     /    \                    /    \
    10    18   (convert to)   18    10
     \                              /
      12                          12
                    </pre>
            
            <strong>Solution: </strong>
            <br>
            We know in a BST, the left child of a node is always less than the node itself. And the right child of a node is always. So, we just need to take a temp variable and <code>SWAP</code> the left subtree and right subtree of the node. And we can do that for each and every node recursively by calling the function itself. 
            <pre class= "border">  
              
  def mirror_BST(self, root): 
    if root is None:  return None

    temp = root.left
    root.left = root.right
    root.right = temp

    self.invertTree(root.left)
    self.invertTree(root.right)

    return root
              
            </pre>
            
            <hr>
            Check out this leetcode problem --> <span class="badge bg-success"> <a href = "https://leetcode.com/problems/invert-binary-tree/" class="text-decoration-none" style="color: white">226. Invert Binary Tree</a></span>
          </div>
        </div>
      </div>
       <!--forth ends--> 

      <!--fifth starts--> 
            <div class="accordion-item">
              <h2 class="accordion-header" id="panelsStayOpen-headingFive">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelsStayOpen-collapseFive" aria-expanded="false" aria-controls="panelsStayOpen-collapseFive">
                 BST to Grater Sum Tree 🔥
                </button>
              </h2>
              <div id="panelsStayOpen-collapseFive" class="accordion-collapse collapse" aria-labelledby="panelsStayOpen-headingFive">
                <div class="accordion-body">
                  Given the <span class="badge bg-dark">root</span> of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. <br><br>
                  <img src="tree.png" class="img-thumbnail">
<br>  
                  <strong>Solution: </strong>
<br> 
                  <span class="badge bg-danger">Important Observation</span> In BST, the left child of a node is always less than the node itself. And the right child of a node is always grater than the node itself. So, for a tree like this -
                  <pre class="border">
      A
    /   \
   B     C </pre>
                  The Order is always <code>C > A > B</code>
                  <br><br> 
                   Let's just focus at this part of the tree. We are at the right most element of the tree. And we know that the right most element is the largest element in the tree.
                  <pre class="border">

      \                        
       6                       
     /   \                     
    5     7                    
           \                   
            8 <-- reached here 
                  </pre>

                  So as we can see, we need to add the sum of all the elements greater than the current node to the current node. And we are at the right most element of the tree. So, the current node value remains the same. Now, we need to go to the root of this current node, and add the value of the current node with the root (2nd largest) . So, 7 becoming (7 + 8) = 15. 
<pre class="border">

      \                        
       6                       
     /   \                     
    5     15 (7+8)  <-- here   
           \                   
            8       

</pre>
                  As 15 (previously 7) has no left node, we now go to it's root (which is the 3rd largest) and add up the value of the current node with the root, so 6 becomes 15+6 = 21. And so on.
<pre class= "border">
  
      \                        
       21 (6+15) <-- here      
     /   \                     
    5     15                   
           \                   
            8 
         
</pre>
                  <span class="badge bg-danger">Important Observation</span> What we're doing here is traversing the tree in such order - <code>right -> root -> left</code>. This is exactly opposit of the Inorder Traversal. So, we can solve this problem in this way, 

                  <ol>
                    <li>
                      <b>Initialize accumulator:</b> Create a variable <code>current_sum</code> and set it to <code>0</code>. This will accumulate the sum of visited nodes.
                    </li>
                    <li>
                      <b>Define a recursive helper function:</b> Define a function named <code>dfs</code> that takes a <code>root</code> node as input.
                      <ul>
                        <li><b>Base case:</b> Check if the <code>root</code> is <code>None</code>. If so, simply return.</li>
                        <li><b>Process right subtree:</b> Call <code>dfs</code> recursively on the <code>root.right</code> subtree. This ensures processing larger values first.</li>
                        <li><b>Update node value:</b> Add the current <code>current_sum</code> to the <code>root.val</code>. This effectively adds the sum of all larger nodes to the current node.</li>
                        <li><b>Update accumulator:</b> Update the <code>current_sum</code> by assigning the current <code>root.val</code> to it. This prepares the sum for the left subtree.</li>
                        <li><b>Process left subtree:</b> Call <code>dfs</code> recursively on the <code>root.left</code> subtree.</li>
                      </ul>
                    </li>
                    <li>
                      <b>Start from root:</b> Call the <code>dfs</code> function with the initial <code>root</code> of the binary search tree.
                    </li>
                    <li>
                      <b>Return modified tree:</b> The function returns the modified <code>root</code> node where each node now stores the sum of all larger nodes in the original tree.
                    </li>
                  </ol>



                  
                  <pre class="border" id="show_code" style= "display: none;">
                    
  def bstToGst(root):
    current_sum  = 0

    def dfs(root):
      nonlocal current_sum
      if root is None:  return 

      dfs(root.right)
      root.val += current_sum
      current_sum = root.val
      dfs(root.left)

    dfs(root)
    return root
                    
                  </pre>
                  <button type="button" class="btn btn-outline-success d-grid col-6 mx-auto" onclick="showHide(this)" id = "myButton">Show Code</button>

                  <hr>
                  Check out this leetcode problem --> <span class="badge bg-warning"> <a href = "https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/description/" class="text-decoration-none" style="color: white">1038. Binary Search Tree to Greater Sum Tree
</a></span>
                </div>
              </div>
            </div>
             <!--fifth ends--> 
      
    </div>
    

  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4"
    crossorigin="anonymous"></script>

  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
<style>

  @font-face {
      font-family: 'Tiro Bangla';
      src: url('/TiroBangla-Regular.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
  }

  body {
        font-family: Arial, sans-serif;
    }
  
</style>
  
</body>

</html>
